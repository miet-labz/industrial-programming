mod matrix;
use matrix::*;
mod input;
use input::*;

fn main() {
  println!("{}", usize::min_value());
  println!("Вас приветствует программа");
  println!("Быстрого перемножения матриц методом Штрассена\n");
  ///////////////////////////////////////////////////////////////////////////////
  ////////////////////Ввод размеров матрицы пользователем////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  println!("Введите размеры первой матрицы\t");
  let (row1, col1) = input_size();
  println!("Введите размеры второй матрицы\t");
  let (row2, col2) = input_size();
  let mut mtrx1 = matrix(row1, col1);
  let mut mtrx2 = matrix(row2, col2);

  ///////////////////////////////////////////////////////////////////////////////
  ////////////////Выбор способа заполнения и заполнение матриц///////////////////
  ///////////////////////////////////////////////////////////////////////////////

  match select_way() {
    Fill::Manually => {
      man_fill_matrix(&mut mtrx1);
      println!("\n");
      man_fill_matrix(&mut mtrx2);
      println!("\nМатрица 1\n");
      print_matrix(&mut mtrx1);
      println!("\nМатрица 2\n");
      print_matrix(&mut mtrx2);
    }
    Fill::Auto => {
      auto_fill_matrix(&mut mtrx1);
      auto_fill_matrix(&mut mtrx2);
      println!("\nМатрица 1\n");
      print_matrix(&mut mtrx1);
      println!("\nМатрица 2\n");
      print_matrix(&mut mtrx2);
    }
  }
  ///////////////////////////////////////////////////////////////////////////////
  /////////////////Приведение матриц к требуемому размеру////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let mut aug_size = 2;
  while aug_size < row1 || aug_size < row2 || aug_size < col1 || aug_size < col2 {
    aug_size *= 2;
  }

  let mut aug_mtrx1 = matrix(aug_size, aug_size);
  let mut aug_mtrx2 = matrix(aug_size, aug_size);

  copy_values(&mut mtrx1, &mut aug_mtrx1);
  copy_values(&mut mtrx2, &mut aug_mtrx2);

  clear_matrix(&mut mtrx1);
  clear_matrix(&mut mtrx2);

  println!("Приведенные матрицы");
  println!("\nМатрица 1\n");
  print_matrix(&mut aug_mtrx1);
  println!("\nМатрица 2\n");
  print_matrix(&mut aug_mtrx2);

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////Разбиение матриц на подматрицы и их заполнение//////////////////
  ///////////////////////////////////////////////////////////////////////////////
  let mut sub_matr = sub_matrices(&mut aug_mtrx1, &mut aug_mtrx2, aug_size / 2);

  clear_matrix(&mut aug_mtrx1);
  clear_matrix(&mut aug_mtrx2);
  ///////////////////////////////////////////////////////////////////////////////
  ////////////////////////Создание промежуточных матриц//////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let mut interm = declare_intermediate_matrices(aug_size / 2);

  ///////////////////////////////////////////////////////////////////////////////
  ////////////////////Вычисление значений промежуточных матриц///////////////////
  ///////////////////////////////////////////////////////////////////////////////

  calc_interm(&mut sub_matr, &mut interm, aug_size / 2);

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////Создание вспомогательных матриц/////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  let mut helpers = vec![matrix(aug_size / 2, aug_size / 2); 4];

  ///////////////////////////////////////////////////////////////////////////////
  ////////////Подсчет значений вспомогательных матриц из промежуточных///////////
  ///////////////////////////////////////////////////////////////////////////////

  calc_helpers(&mut helpers, &mut interm, aug_size / 2);

  for mut i in &mut interm {
    clear_matrix(&mut i);
  }
  interm.clear();
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////Создание результирующей матрицы/////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let mut aug_res_mtrx = matrix(aug_size, aug_size);

  ///////////////////////////////////////////////////////////////////////////////
  ///////Занесение информации из вспомогательных матриц в результирующую/////////
  ///////////////////////////////////////////////////////////////////////////////
  copy_helpers_to_result(&mut helpers, &mut aug_res_mtrx, aug_size / 2);

  for mut i in &mut helpers {
    clear_matrix(&mut i);
  }
  interm.clear();
  ///////////////////////////////////////////////////////////////////////////////
  ////////////////Выравнивание границ результирующей матрицы/////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let (row, col) = matrix_bounds(&mut aug_res_mtrx, aug_size);
  let mut res_mtrx = matrix(row, col);

  copy_values(&mut aug_res_mtrx, &mut res_mtrx);

  clear_matrix(&mut aug_res_mtrx);
  println!("Результирующая матрица");

  print_matrix(&mut res_mtrx);

  clear_matrix(&mut res_mtrx);
}
